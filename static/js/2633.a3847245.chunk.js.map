{"version":3,"file":"static/js/2633.a3847245.chunk.js","mappings":"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","sources":["../node_modules/viem/node_modules/@noble/hashes/src/_assert.ts","../node_modules/viem/utils/cursor.ts","../node_modules/viem/node_modules/@noble/hashes/src/_sha2.ts","../node_modules/viem/node_modules/@noble/hashes/src/sha256.ts","../node_modules/viem/utils/hash/sha256.ts","../node_modules/viem/node_modules/@noble/hashes/src/_u64.ts","../node_modules/viem/node_modules/@noble/hashes/src/sha3.ts","../node_modules/viem/utils/hash/keccak256.ts","../node_modules/viem/utils/formatters/transactionReceipt.ts","../node_modules/viem/utils/blob/blobsToProofs.ts","../node_modules/viem/errors/node.ts","../node_modules/viem/errors/blob.ts","../node_modules/viem/utils/data/concat.ts","../node_modules/viem/errors/transaction.ts","../node_modules/viem/utils/address/getAddress.ts","../node_modules/viem/utils/formatters/transaction.ts","../node_modules/viem/errors/address.ts","../node_modules/viem/utils/formatters/block.ts","../node_modules/viem/constants/blob.ts","../node_modules/viem/utils/blob/toBlobSidecars.ts","../node_modules/viem/utils/blob/toBlobs.ts","../node_modules/viem/utils/address/isAddress.ts","../node_modules/viem/utils/unit/formatGwei.ts","../node_modules/viem/utils/data/slice.ts","../node_modules/viem/errors/chain.ts","../node_modules/viem/node_modules/@noble/hashes/src/utils.ts","../node_modules/viem/utils/formatters/transactionRequest.ts","../node_modules/viem/utils/lru.ts","../node_modules/viem/utils/formatters/log.ts","../node_modules/viem/utils/chain/defineChain.ts","../node_modules/viem/utils/formatters/formatter.ts","../node_modules/viem/utils/transaction/getTransactionType.ts","../node_modules/viem/utils/blob/blobsToCommitments.ts","../node_modules/viem/constants/kzg.ts","../node_modules/viem/utils/blob/commitmentToVersionedHash.ts","../node_modules/viem/utils/blob/commitmentsToVersionedHashes.ts","../node_modules/viem/errors/cursor.ts"],"sourcesContent":["function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\n\nfunction bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\n\nfunction bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!(b instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction hash(hash: Hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\n\nfunction exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nexport { number, bool, bytes, hash, exists, output };\n\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n","import {\n  NegativeOffsetError,\n  PositionOutOfBoundsError,\n  RecursiveReadLimitExceededError,\n} from '../errors/cursor.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { ByteArray } from '../types/misc.js'\n\nexport type Cursor = {\n  bytes: ByteArray\n  dataView: DataView\n  position: number\n  positionReadCount: Map<number, number>\n  recursiveReadCount: number\n  recursiveReadLimit: number\n  remaining: number\n  assertReadLimit(position?: number): void\n  assertPosition(position: number): void\n  decrementPosition(offset: number): void\n  getReadCount(position?: number): number\n  incrementPosition(offset: number): void\n  inspectByte(position?: number): ByteArray[number]\n  inspectBytes(length: number, position?: number): ByteArray\n  inspectUint8(position?: number): number\n  inspectUint16(position?: number): number\n  inspectUint24(position?: number): number\n  inspectUint32(position?: number): number\n  pushByte(byte: ByteArray[number]): void\n  pushBytes(bytes: ByteArray): void\n  pushUint8(value: number): void\n  pushUint16(value: number): void\n  pushUint24(value: number): void\n  pushUint32(value: number): void\n  readByte(): ByteArray[number]\n  readBytes(length: number, size?: number): ByteArray\n  readUint8(): number\n  readUint16(): number\n  readUint24(): number\n  readUint32(): number\n  setPosition(position: number): () => void\n  _touch(): void\n}\n\nexport type CreateCursorErrorType = ErrorType\n\nexport type CursorErrorType =\n  | CursorAssertPositionErrorType\n  | CursorDecrementPositionErrorType\n  | CursorIncrementPositionErrorType\n  | ErrorType\n\nexport type CursorAssertPositionErrorType = PositionOutOfBoundsError | ErrorType\n\nexport type CursorDecrementPositionErrorType = NegativeOffsetError | ErrorType\n\nexport type CursorIncrementPositionErrorType = NegativeOffsetError | ErrorType\n\nconst staticCursor: Cursor = {\n  bytes: new Uint8Array(),\n  dataView: new DataView(new ArrayBuffer(0)),\n  position: 0,\n  positionReadCount: new Map(),\n  recursiveReadCount: 0,\n  recursiveReadLimit: Number.POSITIVE_INFINITY,\n  assertReadLimit() {\n    if (this.recursiveReadCount >= this.recursiveReadLimit)\n      throw new RecursiveReadLimitExceededError({\n        count: this.recursiveReadCount + 1,\n        limit: this.recursiveReadLimit,\n      })\n  },\n  assertPosition(position) {\n    if (position < 0 || position > this.bytes.length - 1)\n      throw new PositionOutOfBoundsError({\n        length: this.bytes.length,\n        position,\n      })\n  },\n  decrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position - offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  getReadCount(position) {\n    return this.positionReadCount.get(position || this.position) || 0\n  },\n  incrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position + offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  inspectByte(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]\n  },\n  inspectBytes(length, position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + length - 1)\n    return this.bytes.subarray(position, position + length)\n  },\n  inspectUint8(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]\n  },\n  inspectUint16(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 1)\n    return this.dataView.getUint16(position)\n  },\n  inspectUint24(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 2)\n    return (\n      (this.dataView.getUint16(position) << 8) +\n      this.dataView.getUint8(position + 2)\n    )\n  },\n  inspectUint32(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 3)\n    return this.dataView.getUint32(position)\n  },\n  pushByte(byte: ByteArray[number]) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = byte\n    this.position++\n  },\n  pushBytes(bytes: ByteArray) {\n    this.assertPosition(this.position + bytes.length - 1)\n    this.bytes.set(bytes, this.position)\n    this.position += bytes.length\n  },\n  pushUint8(value: number) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = value\n    this.position++\n  },\n  pushUint16(value: number) {\n    this.assertPosition(this.position + 1)\n    this.dataView.setUint16(this.position, value)\n    this.position += 2\n  },\n  pushUint24(value: number) {\n    this.assertPosition(this.position + 2)\n    this.dataView.setUint16(this.position, value >> 8)\n    this.dataView.setUint8(this.position + 2, value & ~4294967040)\n    this.position += 3\n  },\n  pushUint32(value: number) {\n    this.assertPosition(this.position + 3)\n    this.dataView.setUint32(this.position, value)\n    this.position += 4\n  },\n  readByte() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectByte()\n    this.position++\n    return value\n  },\n  readBytes(length, size) {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectBytes(length)\n    this.position += size ?? length\n    return value\n  },\n  readUint8() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint8()\n    this.position += 1\n    return value\n  },\n  readUint16() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint16()\n    this.position += 2\n    return value\n  },\n  readUint24() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint24()\n    this.position += 3\n    return value\n  },\n  readUint32() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint32()\n    this.position += 4\n    return value\n  },\n  get remaining() {\n    return this.bytes.length - this.position\n  },\n  setPosition(position) {\n    const oldPosition = this.position\n    this.assertPosition(position)\n    this.position = position\n    return () => (this.position = oldPosition)\n  },\n  _touch() {\n    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return\n    const count = this.getReadCount()\n    this.positionReadCount.set(this.position, count + 1)\n    if (count > 0) this.recursiveReadCount++\n  },\n}\n\ntype CursorConfig = { recursiveReadLimit?: number | undefined }\n\nexport function createCursor(\n  bytes: ByteArray,\n  { recursiveReadLimit = 8_192 }: CursorConfig = {},\n): Cursor {\n  const cursor: Cursor = Object.create(staticCursor)\n  cursor.bytes = bytes\n  cursor.dataView = new DataView(\n    bytes.buffer,\n    bytes.byteOffset,\n    bytes.byteLength,\n  )\n  cursor.positionReadCount = new Map()\n  cursor.recursiveReadLimit = recursiveReadLimit\n  return cursor\n}\n","import { exists, output } from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n// Polyfill for Safari 14\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n// Base SHA2 class (RFC 6234)\nexport abstract class SHA2<T extends SHA2<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    exists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    exists(this);\n    output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n\n// Choice: a ? b : c\nconst Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a: number, b: number, c: number) => (a & b) ^ (a & c) ^ (b & c);\n\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  A = IV[0] | 0;\n  B = IV[1] | 0;\n  C = IV[2] | 0;\n  D = IV[3] | 0;\n  E = IV[4] | 0;\n  F = IV[5] | 0;\n  G = IV[6] | 0;\n  H = IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  A = 0xc1059ed8 | 0;\n  B = 0x367cd507 | 0;\n  C = 0x3070dd17 | 0;\n  D = 0xf70e5939 | 0;\n  E = 0xffc00b31 | 0;\n  F = 0x68581511 | 0;\n  G = 0x64f98fa7 | 0;\n  H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n","import { sha256 as noble_sha256 } from '@noble/hashes/sha256'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Sha256Hash<TTo extends To> =\n  | (TTo extends 'bytes' ? ByteArray : never)\n  | (TTo extends 'hex' ? Hex : never)\n\nexport type Sha256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function sha256<TTo extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: TTo | undefined,\n): Sha256Hash<TTo> {\n  const to = to_ || 'hex'\n  const bytes = noble_sha256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Sha256Hash<TTo>\n  return toHex(bytes) as Sha256Hash<TTo>\n}\n","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n: bigint, le = false) {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number) => h >>> s;\nconst shrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number) => l;\nconst rotr32L = (h: number, _l: number) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number) => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah: number, Al: number, Bh: number, Bl: number) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number) =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number) =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n// prettier-ignore\nconst u64 = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","import { bytes, exists, number, output } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport {\n  Hash,\n  u32,\n  Input,\n  toBytes,\n  wrapConstructor,\n  wrapXOFConstructorWithOpts,\n  HashXOF,\n} from './utils.js';\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA]: [number[], number[], bigint[]] = [[], [], []];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s: Uint32Array, rounds: number = 24) {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta θ\n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho (ρ) and Pi (π)\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi (χ)\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota (ι)\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  B.fill(0);\n}\n\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    public blockLen: number,\n    public suffix: number,\n    public outputLen: number,\n    protected enableXOF = false,\n    protected rounds: number = 24\n  ) {\n    super();\n    // Can be passed from user as dkLen\n    number(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    if (0 >= this.blockLen || this.blockLen >= 200)\n      throw new Error('Sha3 supports only keccak-f1600 function');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  protected keccak() {\n    keccakP(this.state32, this.rounds);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input) {\n    exists(this);\n    const { blockLen, state } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish() {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    exists(this, false);\n    bytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    number(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array) {\n    output(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy() {\n    this.destroyed = true;\n    this.state.fill(0);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\n\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapXOFConstructorWithOpts<HashXOF<Keccak>, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n","import { keccak_256 } from '@noble/hashes/sha3'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Keccak256Hash<TTo extends To> =\n  | (TTo extends 'bytes' ? ByteArray : never)\n  | (TTo extends 'hex' ? Hex : never)\n\nexport type Keccak256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function keccak256<TTo extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: TTo | undefined,\n): Keccak256Hash<TTo> {\n  const to = to_ || 'hex'\n  const bytes = keccak_256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Keccak256Hash<TTo>\n  return toHex(bytes) as Keccak256Hash<TTo>\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type {\n  Chain,\n  ExtractChainFormatterReturnType,\n} from '../../types/chain.js'\nimport type { RpcTransactionReceipt } from '../../types/rpc.js'\nimport type { TransactionReceipt } from '../../types/transaction.js'\nimport type { ExactPartial } from '../../types/utils.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\n\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\nimport { formatLog } from './log.js'\nimport { transactionType } from './transaction.js'\n\nexport type FormattedTransactionReceipt<\n  TChain extends Chain | undefined = undefined,\n> = ExtractChainFormatterReturnType<\n  TChain,\n  'transactionReceipt',\n  TransactionReceipt\n>\n\nexport const receiptStatuses = {\n  '0x0': 'reverted',\n  '0x1': 'success',\n} as const\n\nexport type FormatTransactionReceiptErrorType = ErrorType\n\nexport function formatTransactionReceipt(\n  transactionReceipt: ExactPartial<RpcTransactionReceipt>,\n) {\n  const receipt = {\n    ...transactionReceipt,\n    blockNumber: transactionReceipt.blockNumber\n      ? BigInt(transactionReceipt.blockNumber)\n      : null,\n    contractAddress: transactionReceipt.contractAddress\n      ? transactionReceipt.contractAddress\n      : null,\n    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed\n      ? BigInt(transactionReceipt.cumulativeGasUsed)\n      : null,\n    effectiveGasPrice: transactionReceipt.effectiveGasPrice\n      ? BigInt(transactionReceipt.effectiveGasPrice)\n      : null,\n    gasUsed: transactionReceipt.gasUsed\n      ? BigInt(transactionReceipt.gasUsed)\n      : null,\n    logs: transactionReceipt.logs\n      ? transactionReceipt.logs.map((log) => formatLog(log))\n      : null,\n    to: transactionReceipt.to ? transactionReceipt.to : null,\n    transactionIndex: transactionReceipt.transactionIndex\n      ? hexToNumber(transactionReceipt.transactionIndex)\n      : null,\n    status: transactionReceipt.status\n      ? receiptStatuses[transactionReceipt.status]\n      : null,\n    type: transactionReceipt.type\n      ? transactionType[\n          transactionReceipt.type as keyof typeof transactionType\n        ] || transactionReceipt.type\n      : null,\n  } as TransactionReceipt\n\n  if (transactionReceipt.blobGasPrice)\n    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice)\n  if (transactionReceipt.blobGasUsed)\n    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed)\n\n  return receipt\n}\n\nexport type DefineTransactionReceiptErrorType =\n  | DefineFormatterErrorType\n  | ErrorType\n\nexport const defineTransactionReceipt = /*#__PURE__*/ defineFormatter(\n  'transactionReceipt',\n  formatTransactionReceipt,\n)\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type blobsToProofsParameters<\n  blobs extends readonly ByteArray[] | readonly Hex[],\n  commitments extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n  ///\n  _blobsType =\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\n> = {\n  /** Blobs to transform into proofs. */\n  blobs: blobs\n  /** Commitments for the blobs. */\n  commitments: commitments &\n    (commitments extends _blobsType\n      ? {}\n      : `commitments must be the same type as blobs`)\n  /** KZG implementation. */\n  kzg: Pick<Kzg, 'computeBlobKzgProof'>\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type blobsToProofsReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray[] : never)\n  | (to extends 'hex' ? Hex[] : never)\n\nexport type blobsToProofsErrorType =\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Compute the proofs for a list of blobs and their commitments.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\n * ```\n */\nexport function blobsToProofs<\n  const blobs extends readonly ByteArray[] | readonly Hex[],\n  const commitments extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: blobsToProofsParameters<blobs, commitments, to>,\n): blobsToProofsReturnType<to> {\n  const { kzg } = parameters\n\n  const to =\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\n\n  const blobs = (\n    typeof parameters.blobs[0] === 'string'\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\n      : parameters.blobs\n  ) as ByteArray[]\n  const commitments = (\n    typeof parameters.commitments[0] === 'string'\n      ? parameters.commitments.map((x) => hexToBytes(x as any))\n      : parameters.commitments\n  ) as ByteArray[]\n\n  const proofs: ByteArray[] = []\n  for (let i = 0; i < blobs.length; i++) {\n    const blob = blobs[i]\n    const commitment = commitments[i]\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)))\n  }\n\n  return (to === 'bytes'\n    ? proofs\n    : proofs.map((x) => bytesToHex(x))) as {} as blobsToProofsReturnType<to>\n}\n","import { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { BaseError } from './base.js'\n\n/**\n * geth:    https://github.com/ethereum/go-ethereum/blob/master/core/error.go\n *          https://github.com/ethereum/go-ethereum/blob/master/core/types/transaction.go#L34-L41\n *\n * erigon:  https://github.com/ledgerwatch/erigon/blob/master/core/error.go\n *          https://github.com/ledgerwatch/erigon/blob/master/core/types/transaction.go#L41-L46\n *\n * anvil:   https://github.com/foundry-rs/foundry/blob/master/anvil/src/eth/error.rs#L108\n */\nexport type ExecutionRevertedErrorType = ExecutionRevertedError & {\n  code: 3\n  name: 'ExecutionRevertedError'\n}\nexport class ExecutionRevertedError extends BaseError {\n  static code = 3\n  static nodeMessage = /execution reverted/\n\n  override name = 'ExecutionRevertedError'\n\n  constructor({\n    cause,\n    message,\n  }: { cause?: BaseError | undefined; message?: string | undefined } = {}) {\n    const reason = message\n      ?.replace('execution reverted: ', '')\n      ?.replace('execution reverted', '')\n    super(\n      `Execution reverted ${\n        reason ? `with reason: ${reason}` : 'for an unknown reason'\n      }.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport type FeeCapTooHighErrorType = FeeCapTooHighError & {\n  name: 'FeeCapTooHighError'\n}\nexport class FeeCapTooHighError extends BaseError {\n  static nodeMessage =\n    /max fee per gas higher than 2\\^256-1|fee cap higher than 2\\^256-1/\n  override name = 'FeeCapTooHigh'\n  constructor({\n    cause,\n    maxFeePerGas,\n  }: {\n    cause?: BaseError | undefined\n    maxFeePerGas?: bigint | undefined\n  } = {}) {\n    super(\n      `The fee cap (\\`maxFeePerGas\\`${\n        maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''\n      }) cannot be higher than the maximum allowed value (2^256-1).`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport type FeeCapTooLowErrorType = FeeCapTooLowError & {\n  name: 'FeeCapTooLowError'\n}\nexport class FeeCapTooLowError extends BaseError {\n  static nodeMessage =\n    /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/\n  override name = 'FeeCapTooLow'\n  constructor({\n    cause,\n    maxFeePerGas,\n  }: {\n    cause?: BaseError | undefined\n    maxFeePerGas?: bigint | undefined\n  } = {}) {\n    super(\n      `The fee cap (\\`maxFeePerGas\\`${\n        maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ''\n      } gwei) cannot be lower than the block base fee.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport type NonceTooHighErrorType = NonceTooHighError & {\n  name: 'NonceTooHighError'\n}\nexport class NonceTooHighError extends BaseError {\n  static nodeMessage = /nonce too high/\n  override name = 'NonceTooHighError'\n  constructor({\n    cause,\n    nonce,\n  }: { cause?: BaseError | undefined; nonce?: number | undefined } = {}) {\n    super(\n      `Nonce provided for the transaction ${\n        nonce ? `(${nonce}) ` : ''\n      }is higher than the next one expected.`,\n      { cause },\n    )\n  }\n}\n\nexport type NonceTooLowErrorType = NonceTooLowError & {\n  name: 'NonceTooLowError'\n}\nexport class NonceTooLowError extends BaseError {\n  static nodeMessage =\n    /nonce too low|transaction already imported|already known/\n  override name = 'NonceTooLowError'\n  constructor({\n    cause,\n    nonce,\n  }: { cause?: BaseError | undefined; nonce?: number | undefined } = {}) {\n    super(\n      [\n        `Nonce provided for the transaction ${\n          nonce ? `(${nonce}) ` : ''\n        }is lower than the current nonce of the account.`,\n        'Try increasing the nonce or find the latest nonce with `getTransactionCount`.',\n      ].join('\\n'),\n      { cause },\n    )\n  }\n}\n\nexport type NonceMaxValueErrorType = NonceMaxValueError & {\n  name: 'NonceMaxValueError'\n}\nexport class NonceMaxValueError extends BaseError {\n  static nodeMessage = /nonce has max value/\n  override name = 'NonceMaxValueError'\n  constructor({\n    cause,\n    nonce,\n  }: { cause?: BaseError | undefined; nonce?: number | undefined } = {}) {\n    super(\n      `Nonce provided for the transaction ${\n        nonce ? `(${nonce}) ` : ''\n      }exceeds the maximum allowed nonce.`,\n      { cause },\n    )\n  }\n}\n\nexport type InsufficientFundsErrorType = InsufficientFundsError & {\n  name: 'InsufficientFundsError'\n}\nexport class InsufficientFundsError extends BaseError {\n  static nodeMessage = /insufficient funds/\n  override name = 'InsufficientFundsError'\n  constructor({ cause }: { cause?: BaseError | undefined } = {}) {\n    super(\n      [\n        'The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.',\n      ].join('\\n'),\n      {\n        cause,\n        metaMessages: [\n          'This error could arise when the account does not have enough funds to:',\n          ' - pay for the total gas fee,',\n          ' - pay for the value to send.',\n          ' ',\n          'The cost of the transaction is calculated as `gas * gas fee + value`, where:',\n          ' - `gas` is the amount of gas needed for transaction to execute,',\n          ' - `gas fee` is the gas fee,',\n          ' - `value` is the amount of ether to send to the recipient.',\n        ],\n      },\n    )\n  }\n}\n\nexport type IntrinsicGasTooHighErrorType = IntrinsicGasTooHighError & {\n  name: 'IntrinsicGasTooHighError'\n}\nexport class IntrinsicGasTooHighError extends BaseError {\n  static nodeMessage = /intrinsic gas too high|gas limit reached/\n  override name = 'IntrinsicGasTooHighError'\n  constructor({\n    cause,\n    gas,\n  }: { cause?: BaseError | undefined; gas?: bigint | undefined } = {}) {\n    super(\n      `The amount of gas ${\n        gas ? `(${gas}) ` : ''\n      }provided for the transaction exceeds the limit allowed for the block.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport type IntrinsicGasTooLowErrorType = IntrinsicGasTooLowError & {\n  name: 'IntrinsicGasTooLowError'\n}\nexport class IntrinsicGasTooLowError extends BaseError {\n  static nodeMessage = /intrinsic gas too low/\n  override name = 'IntrinsicGasTooLowError'\n  constructor({\n    cause,\n    gas,\n  }: { cause?: BaseError | undefined; gas?: bigint | undefined } = {}) {\n    super(\n      `The amount of gas ${\n        gas ? `(${gas}) ` : ''\n      }provided for the transaction is too low.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport type TransactionTypeNotSupportedErrorType =\n  TransactionTypeNotSupportedError & {\n    name: 'TransactionTypeNotSupportedError'\n  }\nexport class TransactionTypeNotSupportedError extends BaseError {\n  static nodeMessage = /transaction type not valid/\n  override name = 'TransactionTypeNotSupportedError'\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super('The transaction type is not supported for this chain.', {\n      cause,\n    })\n  }\n}\n\nexport type TipAboveFeeCapErrorType = TipAboveFeeCapError & {\n  name: 'TipAboveFeeCapError'\n}\nexport class TipAboveFeeCapError extends BaseError {\n  static nodeMessage =\n    /max priority fee per gas higher than max fee per gas|tip higher than fee cap/\n  override name = 'TipAboveFeeCapError'\n  constructor({\n    cause,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n  }: {\n    cause?: BaseError | undefined\n    maxPriorityFeePerGas?: bigint | undefined\n    maxFeePerGas?: bigint | undefined\n  } = {}) {\n    super(\n      [\n        `The provided tip (\\`maxPriorityFeePerGas\\`${\n          maxPriorityFeePerGas\n            ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei`\n            : ''\n        }) cannot be higher than the fee cap (\\`maxFeePerGas\\`${\n          maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''\n        }).`,\n      ].join('\\n'),\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport type UnknownNodeErrorType = UnknownNodeError & {\n  name: 'UnknownNodeError'\n}\nexport class UnknownNodeError extends BaseError {\n  override name = 'UnknownNodeError'\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(`An error occurred while executing: ${cause?.shortMessage}`, {\n      cause,\n    })\n  }\n}\n","import { versionedHashVersionKzg } from '../constants/kzg.js'\nimport type { Hash } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport type BlobSizeTooLargeErrorType = BlobSizeTooLargeError & {\n  name: 'BlobSizeTooLargeError'\n}\nexport class BlobSizeTooLargeError extends BaseError {\n  override name = 'BlobSizeTooLargeError'\n  constructor({ maxSize, size }: { maxSize: number; size: number }) {\n    super('Blob size is too large.', {\n      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],\n    })\n  }\n}\n\nexport type EmptyBlobErrorType = EmptyBlobError & {\n  name: 'EmptyBlobError'\n}\nexport class EmptyBlobError extends BaseError {\n  override name = 'EmptyBlobError'\n  constructor() {\n    super('Blob data must not be empty.')\n  }\n}\n\nexport type InvalidVersionedHashSizeErrorType =\n  InvalidVersionedHashSizeError & {\n    name: 'InvalidVersionedHashSizeError'\n  }\nexport class InvalidVersionedHashSizeError extends BaseError {\n  override name = 'InvalidVersionedHashSizeError'\n  constructor({\n    hash,\n    size,\n  }: {\n    hash: Hash\n    size: number\n  }) {\n    super(`Versioned hash \"${hash}\" size is invalid.`, {\n      metaMessages: ['Expected: 32', `Received: ${size}`],\n    })\n  }\n}\n\nexport type InvalidVersionedHashVersionErrorType =\n  InvalidVersionedHashVersionError & {\n    name: 'InvalidVersionedHashVersionError'\n  }\nexport class InvalidVersionedHashVersionError extends BaseError {\n  override name = 'InvalidVersionedHashVersionError'\n  constructor({\n    hash,\n    version,\n  }: {\n    hash: Hash\n    version: number\n  }) {\n    super(`Versioned hash \"${hash}\" version is invalid.`, {\n      metaMessages: [\n        `Expected: ${versionedHashVersionKzg}`,\n        `Received: ${version}`,\n      ],\n    })\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nexport type ConcatReturnType<TValue extends Hex | ByteArray> =\n  TValue extends Hex ? Hex : ByteArray\n\nexport type ConcatErrorType =\n  | ConcatBytesErrorType\n  | ConcatHexErrorType\n  | ErrorType\n\nexport function concat<TValue extends Hex | ByteArray>(\n  values: readonly TValue[],\n): ConcatReturnType<TValue> {\n  if (typeof values[0] === 'string')\n    return concatHex(values as readonly Hex[]) as ConcatReturnType<TValue>\n  return concatBytes(values as readonly ByteArray[]) as ConcatReturnType<TValue>\n}\n\nexport type ConcatBytesErrorType = ErrorType\n\nexport function concatBytes(values: readonly ByteArray[]): ByteArray {\n  let length = 0\n  for (const arr of values) {\n    length += arr.length\n  }\n  const result = new Uint8Array(length)\n  let offset = 0\n  for (const arr of values) {\n    result.set(arr, offset)\n    offset += arr.length\n  }\n  return result\n}\n\nexport type ConcatHexErrorType = ErrorType\n\nexport function concatHex(values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace('0x', ''),\n    '',\n  )}`\n}\n","import type { Account } from '../accounts/types.js'\nimport type { SendTransactionParameters } from '../actions/wallet/sendTransaction.js'\nimport type { BlockTag } from '../types/block.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hash, Hex } from '../types/misc.js'\nimport type { TransactionType } from '../types/transaction.js'\nimport { formatEther } from '../utils/unit/formatEther.js'\nimport { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { BaseError } from './base.js'\n\nexport function prettyPrint(\n  args: Record<string, bigint | number | string | undefined | false | unknown>,\n) {\n  const entries = Object.entries(args)\n    .map(([key, value]) => {\n      if (value === undefined || value === false) return null\n      return [key, value]\n    })\n    .filter(Boolean) as [string, string][]\n  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0)\n  return entries\n    .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n    .join('\\n')\n}\n\nexport type FeeConflictErrorType = FeeConflictError & {\n  name: 'FeeConflictError'\n}\nexport class FeeConflictError extends BaseError {\n  override name = 'FeeConflictError'\n  constructor() {\n    super(\n      [\n        'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',\n        'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport type InvalidLegacyVErrorType = InvalidLegacyVError & {\n  name: 'InvalidLegacyVError'\n}\nexport class InvalidLegacyVError extends BaseError {\n  override name = 'InvalidLegacyVError'\n\n  constructor({ v }: { v: bigint }) {\n    super(`Invalid \\`v\\` value \"${v}\". Expected 27 or 28.`)\n  }\n}\n\nexport type InvalidSerializableTransactionErrorType =\n  InvalidSerializableTransactionError & {\n    name: 'InvalidSerializableTransactionError'\n  }\nexport class InvalidSerializableTransactionError extends BaseError {\n  override name = 'InvalidSerializableTransactionError'\n\n  constructor({ transaction }: { transaction: Record<string, unknown> }) {\n    super('Cannot infer a transaction type from provided transaction.', {\n      metaMessages: [\n        'Provided Transaction:',\n        '{',\n        prettyPrint(transaction),\n        '}',\n        '',\n        'To infer the type, either provide:',\n        '- a `type` to the Transaction, or',\n        '- an EIP-1559 Transaction with `maxFeePerGas`, or',\n        '- an EIP-2930 Transaction with `gasPrice` & `accessList`, or',\n        '- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or',\n        '- a Legacy Transaction with `gasPrice`',\n      ],\n    })\n  }\n}\n\nexport type InvalidSerializedTransactionTypeErrorType =\n  InvalidSerializedTransactionTypeError & {\n    name: 'InvalidSerializedTransactionTypeError'\n  }\nexport class InvalidSerializedTransactionTypeError extends BaseError {\n  override name = 'InvalidSerializedTransactionType'\n\n  serializedType: Hex\n\n  constructor({ serializedType }: { serializedType: Hex }) {\n    super(`Serialized transaction type \"${serializedType}\" is invalid.`)\n\n    this.serializedType = serializedType\n  }\n}\n\nexport type InvalidSerializedTransactionErrorType =\n  InvalidSerializedTransactionError & {\n    name: 'InvalidSerializedTransactionError'\n  }\nexport class InvalidSerializedTransactionError extends BaseError {\n  override name = 'InvalidSerializedTransactionError'\n\n  serializedTransaction: Hex\n  type: TransactionType\n\n  constructor({\n    attributes,\n    serializedTransaction,\n    type,\n  }: {\n    attributes: Record<string, unknown>\n    serializedTransaction: Hex\n    type: TransactionType\n  }) {\n    const missing = Object.entries(attributes)\n      .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))\n      .filter(Boolean)\n    super(`Invalid serialized transaction of type \"${type}\" was provided.`, {\n      metaMessages: [\n        `Serialized Transaction: \"${serializedTransaction}\"`,\n        missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',\n      ].filter(Boolean),\n    })\n\n    this.serializedTransaction = serializedTransaction\n    this.type = type\n  }\n}\n\nexport type InvalidStorageKeySizeErrorType = InvalidStorageKeySizeError & {\n  name: 'InvalidStorageKeySizeError'\n}\nexport class InvalidStorageKeySizeError extends BaseError {\n  override name = 'InvalidStorageKeySizeError'\n\n  constructor({ storageKey }: { storageKey: Hex }) {\n    super(\n      `Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${Math.floor(\n        (storageKey.length - 2) / 2,\n      )} bytes.`,\n    )\n  }\n}\n\nexport type TransactionExecutionErrorType = TransactionExecutionError & {\n  name: 'TransactionExecutionError'\n}\nexport class TransactionExecutionError extends BaseError {\n  override cause: BaseError\n\n  override name = 'TransactionExecutionError'\n\n  constructor(\n    cause: BaseError,\n    {\n      account,\n      docsPath,\n      chain,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    }: Omit<SendTransactionParameters, 'account' | 'chain'> & {\n      account: Account\n      chain?: Chain | undefined\n      docsPath?: string | undefined\n    },\n  ) {\n    const prettyArgs = prettyPrint({\n      chain: chain && `${chain?.name} (id: ${chain?.id})`,\n      from: account?.address,\n      to,\n      value:\n        typeof value !== 'undefined' &&\n        `${formatEther(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,\n      data,\n      gas,\n      gasPrice:\n        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Request Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n    })\n    this.cause = cause\n  }\n}\n\nexport type TransactionNotFoundErrorType = TransactionNotFoundError & {\n  name: 'TransactionNotFoundError'\n}\nexport class TransactionNotFoundError extends BaseError {\n  override name = 'TransactionNotFoundError'\n  constructor({\n    blockHash,\n    blockNumber,\n    blockTag,\n    hash,\n    index,\n  }: {\n    blockHash?: Hash | undefined\n    blockNumber?: bigint | undefined\n    blockTag?: BlockTag | undefined\n    hash?: Hash | undefined\n    index?: number | undefined\n  }) {\n    let identifier = 'Transaction'\n    if (blockTag && index !== undefined)\n      identifier = `Transaction at block time \"${blockTag}\" at index \"${index}\"`\n    if (blockHash && index !== undefined)\n      identifier = `Transaction at block hash \"${blockHash}\" at index \"${index}\"`\n    if (blockNumber && index !== undefined)\n      identifier = `Transaction at block number \"${blockNumber}\" at index \"${index}\"`\n    if (hash) identifier = `Transaction with hash \"${hash}\"`\n    super(`${identifier} could not be found.`)\n  }\n}\n\nexport type TransactionReceiptNotFoundErrorType =\n  TransactionReceiptNotFoundError & {\n    name: 'TransactionReceiptNotFoundError'\n  }\nexport class TransactionReceiptNotFoundError extends BaseError {\n  override name = 'TransactionReceiptNotFoundError'\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Transaction receipt with hash \"${hash}\" could not be found. The Transaction may not be processed on a block yet.`,\n    )\n  }\n}\n\nexport type WaitForTransactionReceiptTimeoutErrorType =\n  WaitForTransactionReceiptTimeoutError & {\n    name: 'WaitForTransactionReceiptTimeoutError'\n  }\nexport class WaitForTransactionReceiptTimeoutError extends BaseError {\n  override name = 'WaitForTransactionReceiptTimeoutError'\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Timed out while waiting for transaction with hash \"${hash}\" to be confirmed.`,\n    )\n  }\n}\n","import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n} from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { LruMap } from '../lru.js'\nimport { type IsAddressErrorType, isAddress } from './isAddress.js'\n\nexport const checksumAddressCache = /*#__PURE__*/ new LruMap<Address>(8192)\n\nexport type ChecksumAddressErrorType =\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ErrorType\n\nexport function checksumAddress(\n  address_: Address,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number | undefined,\n): Address {\n  if (checksumAddressCache.has(`${address_}.${chainId}`))\n    return checksumAddressCache.get(`${address_}.${chainId}`)!\n\n  const hexAddress = chainId\n    ? `${chainId}${address_.toLowerCase()}`\n    : address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  const address = (\n    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress\n  ).split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  const result = `0x${address.join('')}` as const\n  checksumAddressCache.set(`${address_}.${chainId}`, result)\n  return result\n}\n\nexport type GetAddressErrorType =\n  | ChecksumAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nexport function getAddress(\n  address: string,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number,\n): Address {\n  if (!isAddress(address, { strict: false }))\n    throw new InvalidAddressError({ address })\n  return checksumAddress(address, chainId)\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ExtractChainFormatterExclude,\n  ExtractChainFormatterReturnType,\n} from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RpcTransaction } from '../../types/rpc.js'\nimport type { Transaction, TransactionType } from '../../types/transaction.js'\nimport type { ExactPartial, UnionLooseOmit } from '../../types/utils.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\n\ntype TransactionPendingDependencies =\n  | 'blockHash'\n  | 'blockNumber'\n  | 'transactionIndex'\n\nexport type FormattedTransaction<\n  TChain extends Chain | undefined = undefined,\n  TBlockTag extends BlockTag = BlockTag,\n  _FormatterReturnType = ExtractChainFormatterReturnType<\n    TChain,\n    'transaction',\n    Transaction\n  >,\n  _ExcludedPendingDependencies extends string = TransactionPendingDependencies &\n    ExtractChainFormatterExclude<TChain, 'transaction'>,\n> = UnionLooseOmit<_FormatterReturnType, TransactionPendingDependencies> & {\n  [_K in _ExcludedPendingDependencies]: never\n} & Pick<\n    Transaction<bigint, number, TBlockTag extends 'pending' ? true : false>,\n    TransactionPendingDependencies\n  >\n\nexport const transactionType = {\n  '0x0': 'legacy',\n  '0x1': 'eip2930',\n  '0x2': 'eip1559',\n  '0x3': 'eip4844',\n} as const satisfies Record<Hex, TransactionType>\n\nexport type FormatTransactionErrorType = ErrorType\n\nexport function formatTransaction(transaction: ExactPartial<RpcTransaction>) {\n  const transaction_ = {\n    ...transaction,\n    blockHash: transaction.blockHash ? transaction.blockHash : null,\n    blockNumber: transaction.blockNumber\n      ? BigInt(transaction.blockNumber)\n      : null,\n    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : undefined,\n    gas: transaction.gas ? BigInt(transaction.gas) : undefined,\n    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,\n    maxFeePerBlobGas: transaction.maxFeePerBlobGas\n      ? BigInt(transaction.maxFeePerBlobGas)\n      : undefined,\n    maxFeePerGas: transaction.maxFeePerGas\n      ? BigInt(transaction.maxFeePerGas)\n      : undefined,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n      ? BigInt(transaction.maxPriorityFeePerGas)\n      : undefined,\n    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : undefined,\n    to: transaction.to ? transaction.to : null,\n    transactionIndex: transaction.transactionIndex\n      ? Number(transaction.transactionIndex)\n      : null,\n    type: transaction.type\n      ? (transactionType as any)[transaction.type]\n      : undefined,\n    typeHex: transaction.type ? transaction.type : undefined,\n    value: transaction.value ? BigInt(transaction.value) : undefined,\n    v: transaction.v ? BigInt(transaction.v) : undefined,\n  } as Transaction\n\n  transaction_.yParity = (() => {\n    // If `yParity` is provided, we will use it.\n    if (transaction.yParity) return Number(transaction.yParity)\n\n    // If no `yParity` provided, try derive from `v`.\n    if (typeof transaction_.v === 'bigint') {\n      if (transaction_.v === 0n || transaction_.v === 27n) return 0\n      if (transaction_.v === 1n || transaction_.v === 28n) return 1\n      if (transaction_.v >= 35n) return transaction_.v % 2n === 0n ? 1 : 0\n    }\n\n    return undefined\n  })()\n\n  if (transaction_.type === 'legacy') {\n    delete transaction_.accessList\n    delete transaction_.maxFeePerBlobGas\n    delete transaction_.maxFeePerGas\n    delete transaction_.maxPriorityFeePerGas\n    delete transaction_.yParity\n  }\n  if (transaction_.type === 'eip2930') {\n    delete transaction_.maxFeePerBlobGas\n    delete transaction_.maxFeePerGas\n    delete transaction_.maxPriorityFeePerGas\n  }\n  if (transaction_.type === 'eip1559') {\n    delete transaction_.maxFeePerBlobGas\n  }\n  return transaction_\n}\n\nexport type DefineTransactionErrorType = DefineFormatterErrorType | ErrorType\n\nexport const defineTransaction = /*#__PURE__*/ defineFormatter(\n  'transaction',\n  formatTransaction,\n)\n","import { BaseError } from './base.js'\n\nexport type InvalidAddressErrorType = InvalidAddressError & {\n  name: 'InvalidAddressError'\n}\nexport class InvalidAddressError extends BaseError {\n  override name = 'InvalidAddressError'\n  constructor({ address }: { address: string }) {\n    super(`Address \"${address}\" is invalid.`, {\n      metaMessages: [\n        '- Address must be a hex value of 20 bytes (40 hex characters).',\n        '- Address must match its checksum counterpart.',\n      ],\n    })\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Block, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ExtractChainFormatterExclude,\n  ExtractChainFormatterReturnType,\n} from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { RpcBlock } from '../../types/rpc.js'\nimport type { ExactPartial, Prettify } from '../../types/utils.js'\n\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\nimport { type FormattedTransaction, formatTransaction } from './transaction.js'\n\ntype BlockPendingDependencies = 'hash' | 'logsBloom' | 'nonce' | 'number'\n\nexport type FormattedBlock<\n  TChain extends Chain | undefined = undefined,\n  TIncludeTransactions extends boolean = boolean,\n  TBlockTag extends BlockTag = BlockTag,\n  _FormatterReturnType = ExtractChainFormatterReturnType<\n    TChain,\n    'block',\n    Block<bigint, TIncludeTransactions>\n  >,\n  _ExcludedPendingDependencies extends string = BlockPendingDependencies &\n    ExtractChainFormatterExclude<TChain, 'block'>,\n  _Formatted = Omit<_FormatterReturnType, BlockPendingDependencies> & {\n    [_key in _ExcludedPendingDependencies]: never\n  } & Pick<\n      Block<bigint, TIncludeTransactions, TBlockTag>,\n      BlockPendingDependencies\n    >,\n  _Transactions = TIncludeTransactions extends true\n    ? Prettify<FormattedTransaction<TChain, TBlockTag>>[]\n    : Hash[],\n> = Omit<_Formatted, 'transactions'> & {\n  transactions: _Transactions\n}\n\nexport type FormatBlockErrorType = ErrorType\n\nexport function formatBlock(block: ExactPartial<RpcBlock>) {\n  const transactions = block.transactions?.map((transaction) => {\n    if (typeof transaction === 'string') return transaction\n    return formatTransaction(transaction)\n  })\n  return {\n    ...block,\n    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,\n    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,\n    difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,\n    excessBlobGas: block.excessBlobGas\n      ? BigInt(block.excessBlobGas)\n      : undefined,\n    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,\n    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,\n    hash: block.hash ? block.hash : null,\n    logsBloom: block.logsBloom ? block.logsBloom : null,\n    nonce: block.nonce ? block.nonce : null,\n    number: block.number ? BigInt(block.number) : null,\n    size: block.size ? BigInt(block.size) : undefined,\n    timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,\n    transactions,\n    totalDifficulty: block.totalDifficulty\n      ? BigInt(block.totalDifficulty)\n      : null,\n  } as Block\n}\n\nexport type DefineBlockErrorType = DefineFormatterErrorType | ErrorType\n\nexport const defineBlock = /*#__PURE__*/ defineFormatter('block', formatBlock)\n","// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\n\n/** Blob limit per transaction. */\nexport const blobsPerTransaction = 6\n\n/** The number of bytes in a BLS scalar field element. */\nexport const bytesPerFieldElement = 32\n\n/** The number of field elements in a blob. */\nexport const fieldElementsPerBlob = 4096\n\n/** The number of bytes in a blob. */\nexport const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob\n\n/** Blob bytes limit per transaction. */\nexport const maxBytesPerTransaction =\n  bytesPerBlob * blobsPerTransaction -\n  // terminator byte (0x80).\n  1 -\n  // zero byte (0x00) appended to each field element.\n  1 * fieldElementsPerBlob * blobsPerTransaction\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { BlobSidecars } from '../../types/eip4844.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type BlobsToCommitmentsErrorType,\n  blobsToCommitments,\n} from './blobsToCommitments.js'\nimport { blobsToProofs, type blobsToProofsErrorType } from './blobsToProofs.js'\nimport { type ToBlobsErrorType, toBlobs } from './toBlobs.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type ToBlobSidecarsParameters<\n  data extends Hex | ByteArray | undefined = undefined,\n  blobs extends readonly Hex[] | readonly ByteArray[] | undefined = undefined,\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n  ///\n  _blobsType =\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\n> = {\n  /** Return type. */\n  to?: to | To | undefined\n} & OneOf<\n  | {\n      /** Data to transform into blobs. */\n      data: data | Hex | ByteArray\n      /** KZG implementation. */\n      kzg: Kzg\n    }\n  | {\n      /** Blobs. */\n      blobs: blobs | readonly Hex[] | readonly ByteArray[]\n      /** Commitment for each blob. */\n      commitments: _blobsType | readonly Hex[] | readonly ByteArray[]\n      /** Proof for each blob. */\n      proofs: _blobsType | readonly Hex[] | readonly ByteArray[]\n    }\n>\n\nexport type ToBlobSidecarsReturnType<to extends To> =\n  | (to extends 'bytes' ? BlobSidecars<ByteArray> : never)\n  | (to extends 'hex' ? BlobSidecars<Hex> : never)\n\nexport type ToBlobSidecarsErrorType =\n  | BlobsToCommitmentsErrorType\n  | ToBlobsErrorType\n  | blobsToProofsErrorType\n  | ErrorType\n\n/**\n * Transforms arbitrary data (or blobs, commitments, & proofs) into a sidecar array.\n *\n * @example\n * ```ts\n * import { toBlobSidecars, stringToHex } from 'viem'\n *\n * const sidecars = toBlobSidecars({ data: stringToHex('hello world') })\n * ```\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   toBlobs,\n *   blobsToProofs,\n *   toBlobSidecars,\n *   stringToHex\n * } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\n *\n * const sidecars = toBlobSidecars({ blobs, commitments, proofs })\n * ```\n */\nexport function toBlobSidecars<\n  const data extends Hex | ByteArray | undefined = undefined,\n  const blobs extends\n    | readonly Hex[]\n    | readonly ByteArray[]\n    | undefined = undefined,\n  to extends To =\n    | (data extends Hex ? 'hex' : never)\n    | (data extends ByteArray ? 'bytes' : never)\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: ToBlobSidecarsParameters<data, blobs, to>,\n): ToBlobSidecarsReturnType<to> {\n  const { data, kzg, to } = parameters\n  const blobs = parameters.blobs ?? toBlobs({ data: data!, to })\n  const commitments =\n    parameters.commitments ?? blobsToCommitments({ blobs, kzg: kzg!, to })\n  const proofs =\n    parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg: kzg!, to })\n\n  const sidecars: BlobSidecars = []\n  for (let i = 0; i < blobs.length; i++)\n    sidecars.push({\n      blob: blobs[i],\n      commitment: commitments[i],\n      proof: proofs[i],\n    })\n\n  return sidecars as ToBlobSidecarsReturnType<to>\n}\n","import {\n  bytesPerBlob,\n  bytesPerFieldElement,\n  fieldElementsPerBlob,\n  maxBytesPerTransaction,\n} from '../../constants/blob.js'\nimport {\n  BlobSizeTooLargeError,\n  type BlobSizeTooLargeErrorType,\n  EmptyBlobError,\n  type EmptyBlobErrorType,\n} from '../../errors/blob.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { createCursor } from '../cursor.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type ToBlobsParameters<\n  data extends Hex | ByteArray = Hex | ByteArray,\n  to extends To | undefined = undefined,\n> = {\n  /** Data to transform to a blob. */\n  data: data | Hex | ByteArray\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type ToBlobsReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type ToBlobsErrorType =\n  | BlobSizeTooLargeErrorType\n  | BytesToHexErrorType\n  | EmptyBlobErrorType\n  | HexToBytesErrorType\n  | SizeErrorType\n  | ErrorType\n\n/**\n * Transforms arbitrary data to blobs.\n *\n * @example\n * ```ts\n * import { toBlobs, stringToHex } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * ```\n */\nexport function toBlobs<\n  const data extends Hex | ByteArray,\n  to extends To =\n    | (data extends Hex ? 'hex' : never)\n    | (data extends ByteArray ? 'bytes' : never),\n>(parameters: ToBlobsParameters<data, to>): ToBlobsReturnType<to> {\n  const to =\n    parameters.to ?? (typeof parameters.data === 'string' ? 'hex' : 'bytes')\n  const data = (\n    typeof parameters.data === 'string'\n      ? hexToBytes(parameters.data)\n      : parameters.data\n  ) as ByteArray\n\n  const size_ = size(data)\n  if (!size_) throw new EmptyBlobError()\n  if (size_ > maxBytesPerTransaction)\n    throw new BlobSizeTooLargeError({\n      maxSize: maxBytesPerTransaction,\n      size: size_,\n    })\n\n  const blobs = []\n\n  let active = true\n  let position = 0\n  while (active) {\n    const blob = createCursor(new Uint8Array(bytesPerBlob))\n\n    let size = 0\n    while (size < fieldElementsPerBlob) {\n      const bytes = data.slice(position, position + (bytesPerFieldElement - 1))\n\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\n      blob.pushByte(0x00)\n\n      // Push the current segment of data bytes.\n      blob.pushBytes(bytes)\n\n      // If we detect that the current segment of data bytes is less than 31 bytes,\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\n      if (bytes.length < 31) {\n        blob.pushByte(0x80)\n        active = false\n        break\n      }\n\n      size++\n      position += 31\n    }\n\n    blobs.push(blob)\n  }\n\n  return (\n    to === 'bytes'\n      ? blobs.map((x) => x.bytes)\n      : blobs.map((x) => bytesToHex(x.bytes))\n  ) as any\n}\n","import type { Address } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { LruMap } from '../lru.js'\nimport { checksumAddress } from './getAddress.js'\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/\n\nexport const isAddressCache = /*#__PURE__*/ new LruMap<boolean>(8192)\n\nexport type IsAddressOptions = {\n  /**\n   * Enables strict mode. Whether or not to compare the address against its checksum.\n   *\n   * @default true\n   */\n  strict?: boolean | undefined\n}\n\nexport type IsAddressErrorType = ErrorType\n\nexport function isAddress(\n  address: string,\n  options?: IsAddressOptions | undefined,\n): address is Address {\n  const { strict = true } = options ?? {}\n\n  if (isAddressCache.has(address)) return isAddressCache.get(address)!\n\n  const result = (() => {\n    if (!addressRegex.test(address)) return false\n    if (address.toLowerCase() === address) return true\n    if (strict) return checksumAddress(address as Address) === address\n    return true\n  })()\n  isAddressCache.set(address, result)\n  return result\n}\n","import { gweiUnits } from '../../constants/unit.js'\n\nimport { type FormatUnitsErrorType, formatUnits } from './formatUnits.js'\n\nexport type FormatGweiErrorType = FormatUnitsErrorType\n\n/**\n * Converts numerical wei to a string representation of gwei.\n *\n * - Docs: https://viem.sh/docs/utilities/formatGwei\n *\n * @example\n * import { formatGwei } from 'viem'\n *\n * formatGwei(1000000000n)\n * // '1'\n */\nexport function formatGwei(wei: bigint, unit: 'wei' = 'wei') {\n  return formatUnits(wei, gweiUnits[unit])\n}\n","import {\n  SliceOffsetOutOfBoundsError,\n  type SliceOffsetOutOfBoundsErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { type IsHexErrorType, isHex } from './isHex.js'\nimport { type SizeErrorType, size } from './size.js'\n\nexport type SliceReturnType<TValue extends ByteArray | Hex> = TValue extends Hex\n  ? Hex\n  : ByteArray\n\nexport type SliceErrorType =\n  | IsHexErrorType\n  | SliceBytesErrorType\n  | SliceHexErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice<TValue extends ByteArray | Hex>(\n  value: TValue,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): SliceReturnType<TValue> {\n  if (isHex(value, { strict: false }))\n    return sliceHex(value as Hex, start, end, {\n      strict,\n    }) as SliceReturnType<TValue>\n  return sliceBytes(value as ByteArray, start, end, {\n    strict,\n  }) as SliceReturnType<TValue>\n}\n\nexport type AssertStartOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertStartOffset(value: Hex | ByteArray, start?: number | undefined) {\n  if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n    throw new SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: size(value),\n    })\n}\n\nexport type AssertEndOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertEndOffset(\n  value: Hex | ByteArray,\n  start?: number | undefined,\n  end?: number | undefined,\n) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    size(value) !== end - start\n  ) {\n    throw new SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: size(value),\n    })\n  }\n}\n\nexport type SliceBytesErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(\n  value_: ByteArray,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): ByteArray {\n  assertStartOffset(value_, start)\n  const value = value_.slice(start, end)\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n\nexport type SliceHexErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(\n  value_: Hex,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): Hex {\n  assertStartOffset(value_, start)\n  const value = `0x${value_\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}` as const\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n","import type { Chain } from '../types/chain.js'\n\nimport { BaseError } from './base.js'\n\nexport type ChainDoesNotSupportContractErrorType =\n  ChainDoesNotSupportContract & {\n    name: 'ChainDoesNotSupportContract'\n  }\nexport class ChainDoesNotSupportContract extends BaseError {\n  override name = 'ChainDoesNotSupportContract'\n  constructor({\n    blockNumber,\n    chain,\n    contract,\n  }: {\n    blockNumber?: bigint | undefined\n    chain: Chain\n    contract: { name: string; blockCreated?: number | undefined }\n  }) {\n    super(\n      `Chain \"${chain.name}\" does not support contract \"${contract.name}\".`,\n      {\n        metaMessages: [\n          'This could be due to any of the following:',\n          ...(blockNumber &&\n          contract.blockCreated &&\n          contract.blockCreated > blockNumber\n            ? [\n                `- The contract \"${contract.name}\" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`,\n              ]\n            : [\n                `- The chain does not have the contract \"${contract.name}\" configured.`,\n              ]),\n        ],\n      },\n    )\n  }\n}\n\nexport type ChainMismatchErrorType = ChainMismatchError & {\n  name: 'ChainMismatchError'\n}\nexport class ChainMismatchError extends BaseError {\n  override name = 'ChainMismatchError'\n\n  constructor({\n    chain,\n    currentChainId,\n  }: {\n    chain: Chain\n    currentChainId: number\n  }) {\n    super(\n      `The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} – ${chain.name}).`,\n      {\n        metaMessages: [\n          `Current Chain ID:  ${currentChainId}`,\n          `Expected Chain ID: ${chain.id} – ${chain.name}`,\n        ],\n      },\n    )\n  }\n}\n\nexport type ChainNotFoundErrorType = ChainNotFoundError & {\n  name: 'ChainNotFoundError'\n}\nexport class ChainNotFoundError extends BaseError {\n  override name = 'ChainNotFoundError'\n\n  constructor() {\n    super(\n      [\n        'No chain was provided to the request.',\n        'Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport type ClientChainNotConfiguredErrorType =\n  ClientChainNotConfiguredError & {\n    name: 'ClientChainNotConfiguredError'\n  }\nexport class ClientChainNotConfiguredError extends BaseError {\n  override name = 'ClientChainNotConfiguredError'\n\n  constructor() {\n    super('No chain was provided to the Client.')\n  }\n}\n\nexport type InvalidChainIdErrorType = InvalidChainIdError & {\n  name: 'InvalidChainIdError'\n}\nexport class InvalidChainIdError extends BaseError {\n  override name = 'InvalidChainIdError'\n\n  constructor({ chainId }: { chainId?: number | undefined }) {\n    super(\n      typeof chainId === 'number'\n        ? `Chain ID \"${chainId}\" is invalid.`\n        : 'Chain ID is invalid.',\n    )\n  }\n}\n","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach((a) => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\nconst toStr = {}.toString;\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type {\n  Chain,\n  ExtractChainFormatterParameters,\n} from '../../types/chain.js'\nimport type { ByteArray } from '../../types/misc.js'\nimport type { RpcTransactionRequest } from '../../types/rpc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { ExactPartial } from '../../types/utils.js'\nimport { bytesToHex, numberToHex } from '../encoding/toHex.js'\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\n\nexport type FormattedTransactionRequest<\n  TChain extends Chain | undefined = Chain | undefined,\n> = ExtractChainFormatterParameters<\n  TChain,\n  'transactionRequest',\n  TransactionRequest\n>\n\nexport const rpcTransactionType = {\n  legacy: '0x0',\n  eip2930: '0x1',\n  eip1559: '0x2',\n  eip4844: '0x3',\n} as const\n\nexport type FormatTransactionRequestErrorType = ErrorType\n\nexport function formatTransactionRequest(\n  request: ExactPartial<TransactionRequest>,\n) {\n  const rpcRequest = {} as RpcTransactionRequest\n\n  if (typeof request.accessList !== 'undefined')\n    rpcRequest.accessList = request.accessList\n  if (typeof request.blobVersionedHashes !== 'undefined')\n    rpcRequest.blobVersionedHashes = request.blobVersionedHashes\n  if (typeof request.blobs !== 'undefined') {\n    if (typeof request.blobs[0] !== 'string')\n      rpcRequest.blobs = (request.blobs as ByteArray[]).map((x) =>\n        bytesToHex(x),\n      )\n    else rpcRequest.blobs = request.blobs\n  }\n  if (typeof request.data !== 'undefined') rpcRequest.data = request.data\n  if (typeof request.from !== 'undefined') rpcRequest.from = request.from\n  if (typeof request.gas !== 'undefined')\n    rpcRequest.gas = numberToHex(request.gas)\n  if (typeof request.gasPrice !== 'undefined')\n    rpcRequest.gasPrice = numberToHex(request.gasPrice)\n  if (typeof request.maxFeePerBlobGas !== 'undefined')\n    rpcRequest.maxFeePerBlobGas = numberToHex(request.maxFeePerBlobGas)\n  if (typeof request.maxFeePerGas !== 'undefined')\n    rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas)\n  if (typeof request.maxPriorityFeePerGas !== 'undefined')\n    rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas)\n  if (typeof request.nonce !== 'undefined')\n    rpcRequest.nonce = numberToHex(request.nonce)\n  if (typeof request.to !== 'undefined') rpcRequest.to = request.to\n  if (typeof request.type !== 'undefined')\n    rpcRequest.type = rpcTransactionType[request.type]\n  if (typeof request.value !== 'undefined')\n    rpcRequest.value = numberToHex(request.value)\n\n  return rpcRequest\n}\n\nexport type DefineTransactionRequestErrorType =\n  | DefineFormatterErrorType\n  | ErrorType\n\nexport const defineTransactionRequest = /*#__PURE__*/ defineFormatter(\n  'transactionRequest',\n  formatTransactionRequest,\n)\n","/**\n * Map with a LRU (Least recently used) policy.\n *\n * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap<value = unknown> extends Map<string, value> {\n  maxSize: number\n\n  constructor(size: number) {\n    super()\n    this.maxSize = size\n  }\n\n  override set(key: string, value: value) {\n    super.set(key, value)\n    if (this.maxSize && this.size > this.maxSize)\n      this.delete(this.keys().next().value)\n    return this\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Log } from '../../types/log.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport type { ExactPartial } from '../../types/utils.js'\n\nexport type FormatLogErrorType = ErrorType\n\nexport function formatLog(\n  log: ExactPartial<RpcLog>,\n  {\n    args,\n    eventName,\n  }: { args?: unknown | undefined; eventName?: string | undefined } = {},\n) {\n  return {\n    ...log,\n    blockHash: log.blockHash ? log.blockHash : null,\n    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,\n    logIndex: log.logIndex ? Number(log.logIndex) : null,\n    transactionHash: log.transactionHash ? log.transactionHash : null,\n    transactionIndex: log.transactionIndex\n      ? Number(log.transactionIndex)\n      : null,\n    ...(eventName ? { args, eventName } : {}),\n  } as Log\n}\n","import type { Chain, ChainFormatters } from '../../types/chain.js'\nimport type { Assign, Prettify } from '../../types/utils.js'\n\nexport function defineChain<\n  formatters extends ChainFormatters,\n  const chain extends Chain<formatters>,\n>(chain: chain): Prettify<Assign<Chain<undefined>, chain>> {\n  return {\n    formatters: undefined,\n    fees: undefined,\n    serializers: undefined,\n    ...chain,\n  } as Assign<Chain<undefined>, chain>\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Assign, Prettify } from '../../types/utils.js'\n\nexport type DefineFormatterErrorType = ErrorType\n\nexport function defineFormatter<TType extends string, TParameters, TReturnType>(\n  type: TType,\n  format: (_: TParameters) => TReturnType,\n) {\n  return <\n    TOverrideParameters,\n    TOverrideReturnType,\n    TExclude extends (keyof TParameters | keyof TOverrideParameters)[] = [],\n  >({\n    exclude,\n    format: overrides,\n  }: {\n    exclude?: TExclude | undefined\n    format: (_: TOverrideParameters) => TOverrideReturnType\n  }) => {\n    return {\n      exclude,\n      format: (args: Assign<TParameters, TOverrideParameters>) => {\n        const formatted = format(args as any)\n        if (exclude) {\n          for (const key of exclude) {\n            delete (formatted as any)[key]\n          }\n        }\n        return {\n          ...formatted,\n          ...overrides(args),\n        } as Prettify<Assign<TReturnType, TOverrideReturnType>> & {\n          [_key in TExclude[number]]: never\n        }\n      },\n      type,\n    }\n  }\n}\n","import {\n  InvalidSerializableTransactionError,\n  type InvalidSerializableTransactionErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  FeeValuesEIP1559,\n  FeeValuesEIP4844,\n  FeeValuesLegacy,\n} from '../../index.js'\nimport type {\n  TransactionRequestEIP1559,\n  TransactionRequestEIP2930,\n  TransactionRequestEIP4844,\n  TransactionRequestGeneric,\n  TransactionRequestLegacy,\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableGeneric,\n  TransactionSerializableLegacy,\n} from '../../types/transaction.js'\nimport type {\n  Assign,\n  ExactPartial,\n  IsNever,\n  OneOf,\n  Opaque,\n} from '../../types/utils.js'\n\ntype BaseProperties = {\n  accessList?: undefined\n  blobs?: undefined\n  blobVersionedHashes?: undefined\n  gasPrice?: undefined\n  maxFeePerBlobGas?: undefined\n  maxFeePerGas?: undefined\n  maxPriorityFeePerGas?: undefined\n  sidecars?: undefined\n}\n\ntype LegacyProperties = Assign<BaseProperties, FeeValuesLegacy>\ntype EIP1559Properties = Assign<\n  BaseProperties,\n  OneOf<\n    | {\n        maxFeePerGas: FeeValuesEIP1559['maxFeePerGas']\n      }\n    | {\n        maxPriorityFeePerGas: FeeValuesEIP1559['maxPriorityFeePerGas']\n      },\n    FeeValuesEIP1559\n  > & {\n    accessList?: TransactionSerializableEIP2930['accessList'] | undefined\n  }\n>\ntype EIP2930Properties = Assign<\n  BaseProperties,\n  ExactPartial<FeeValuesLegacy> & {\n    accessList: TransactionSerializableEIP2930['accessList']\n  }\n>\ntype EIP4844Properties = Assign<\n  BaseProperties,\n  ExactPartial<FeeValuesEIP4844> &\n    OneOf<\n      | {\n          blobs: TransactionSerializableEIP4844['blobs']\n        }\n      | {\n          blobVersionedHashes: TransactionSerializableEIP4844['blobVersionedHashes']\n        }\n      | {\n          sidecars: TransactionSerializableEIP4844['sidecars']\n        },\n      TransactionSerializableEIP4844\n    >\n>\n\nexport type GetTransactionType<\n  transaction extends OneOf<\n    TransactionSerializableGeneric | TransactionRequestGeneric\n  > = TransactionSerializableGeneric,\n  result =\n    | (transaction extends\n        | Opaque<TransactionSerializableLegacy, transaction>\n        | Opaque<TransactionRequestLegacy, transaction>\n        | LegacyProperties\n        ? 'legacy'\n        : never)\n    | (transaction extends\n        | Opaque<TransactionSerializableEIP1559, transaction>\n        | Opaque<TransactionRequestEIP1559, transaction>\n        | EIP1559Properties\n        ? 'eip1559'\n        : never)\n    | (transaction extends\n        | Opaque<TransactionSerializableEIP2930, transaction>\n        | Opaque<TransactionRequestEIP2930, transaction>\n        | EIP2930Properties\n        ? 'eip2930'\n        : never)\n    | (transaction extends\n        | Opaque<TransactionSerializableEIP4844, transaction>\n        | Opaque<TransactionRequestEIP4844, transaction>\n        | EIP4844Properties\n        ? 'eip4844'\n        : never)\n    | (transaction['type'] extends string ? transaction['type'] : never),\n> = IsNever<result> extends false ? result : string\n\nexport type GetTransationTypeErrorType =\n  | InvalidSerializableTransactionErrorType\n  | ErrorType\n\nexport function getTransactionType<\n  const transaction extends OneOf<\n    TransactionSerializableGeneric | TransactionRequestGeneric\n  >,\n>(transaction: transaction): GetTransactionType<transaction> {\n  if (transaction.type)\n    return transaction.type as GetTransactionType<transaction>\n\n  if (\n    typeof transaction.blobs !== 'undefined' ||\n    typeof transaction.blobVersionedHashes !== 'undefined' ||\n    typeof transaction.maxFeePerBlobGas !== 'undefined' ||\n    typeof transaction.sidecars !== 'undefined'\n  )\n    return 'eip4844' as any\n\n  if (\n    typeof transaction.maxFeePerGas !== 'undefined' ||\n    typeof transaction.maxPriorityFeePerGas !== 'undefined'\n  ) {\n    return 'eip1559' as any\n  }\n\n  if (typeof transaction.gasPrice !== 'undefined') {\n    if (typeof transaction.accessList !== 'undefined') return 'eip2930' as any\n    return 'legacy' as any\n  }\n\n  throw new InvalidSerializableTransactionError({ transaction })\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type BlobsToCommitmentsParameters<\n  blobs extends readonly ByteArray[] | readonly Hex[] =\n    | readonly ByteArray[]\n    | readonly Hex[],\n  to extends To | undefined = undefined,\n> = {\n  /** Blobs to transform into commitments. */\n  blobs: blobs | readonly ByteArray[] | readonly Hex[]\n  /** KZG implementation. */\n  kzg: Pick<Kzg, 'blobToKzgCommitment'>\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type BlobsToCommitmentsReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type BlobsToCommitmentsErrorType =\n  | HexToBytesErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\n/**\n * Compute commitments from a list of blobs.\n *\n * @example\n * ```ts\n * import { blobsToCommitments, toBlobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * ```\n */\nexport function blobsToCommitments<\n  const blobs extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: BlobsToCommitmentsParameters<blobs, to>,\n): BlobsToCommitmentsReturnType<to> {\n  const { kzg } = parameters\n\n  const to =\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\n  const blobs = (\n    typeof parameters.blobs[0] === 'string'\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\n      : parameters.blobs\n  ) as ByteArray[]\n\n  const commitments: ByteArray[] = []\n  for (const blob of blobs)\n    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)))\n\n  return (to === 'bytes'\n    ? commitments\n    : commitments.map((x) =>\n        bytesToHex(x),\n      )) as {} as BlobsToCommitmentsReturnType<to>\n}\n","// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\n\n/** The number of bytes in a KZG commitment. */\nexport const bytesPerCommitment = 48\n\n/** The number of bytes in a KZG proof. */\nexport const bytesPerProof = 48\n\nexport const versionedHashVersionKzg = 1\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\nimport { type Sha256ErrorType, sha256 } from '../hash/sha256.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type CommitmentToVersionedHashParameters<\n  commitment extends Uint8Array | Hex = Uint8Array | Hex,\n  to extends To | undefined = undefined,\n> = {\n  /** Commitment from blob. */\n  commitment: commitment | Uint8Array | Hex\n  /** Return type. */\n  to?: to | To | undefined\n  /** Version to tag onto the hash. */\n  version?: number | undefined\n}\n\nexport type CommitmentToVersionedHashReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type CommitmentToVersionedHashErrorType =\n  | Sha256ErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\n/**\n * Transform a commitment to it's versioned hash.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   commitmentToVersionedHash,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const [commitment] = blobsToCommitments({ blobs, kzg })\n * const versionedHash = commitmentToVersionedHash({ commitment })\n * ```\n */\nexport function commitmentToVersionedHash<\n  const commitment extends Hex | ByteArray,\n  to extends To =\n    | (commitment extends Hex ? 'hex' : never)\n    | (commitment extends ByteArray ? 'bytes' : never),\n>(\n  parameters: CommitmentToVersionedHashParameters<commitment, to>,\n): CommitmentToVersionedHashReturnType<to> {\n  const { commitment, version = 1 } = parameters\n  const to = parameters.to ?? (typeof commitment === 'string' ? 'hex' : 'bytes')\n\n  const versionedHash = sha256(commitment, 'bytes')\n  versionedHash.set([version], 0)\n  return (\n    to === 'bytes' ? versionedHash : bytesToHex(versionedHash)\n  ) as CommitmentToVersionedHashReturnType<to>\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CommitmentToVersionedHashErrorType,\n  commitmentToVersionedHash,\n} from './commitmentToVersionedHash.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type CommitmentsToVersionedHashesParameters<\n  commitments extends readonly Uint8Array[] | readonly Hex[] =\n    | readonly Uint8Array[]\n    | readonly Hex[],\n  to extends To | undefined = undefined,\n> = {\n  /** Commitments from blobs. */\n  commitments: commitments | readonly Uint8Array[] | readonly Hex[]\n  /** Return type. */\n  to?: to | To | undefined\n  /** Version to tag onto the hashes. */\n  version?: number | undefined\n}\n\nexport type CommitmentsToVersionedHashesReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type CommitmentsToVersionedHashesErrorType =\n  | CommitmentToVersionedHashErrorType\n  | ErrorType\n\n/**\n * Transform a list of commitments to their versioned hashes.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   commitmentsToVersionedHashes,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const versionedHashes = commitmentsToVersionedHashes({ commitments })\n * ```\n */\nexport function commitmentsToVersionedHashes<\n  const commitments extends readonly Uint8Array[] | readonly Hex[],\n  to extends To =\n    | (commitments extends readonly Hex[] ? 'hex' : never)\n    | (commitments extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: CommitmentsToVersionedHashesParameters<commitments, to>,\n): CommitmentsToVersionedHashesReturnType<to> {\n  const { commitments, version } = parameters\n\n  const to =\n    parameters.to ?? (typeof commitments[0] === 'string' ? 'hex' : 'bytes')\n\n  const hashes: Uint8Array[] | Hex[] = []\n  for (const commitment of commitments) {\n    hashes.push(\n      commitmentToVersionedHash({\n        commitment,\n        to,\n        version,\n      }) as any,\n    )\n  }\n  return hashes as any\n}\n","import { BaseError } from './base.js'\n\nexport type NegativeOffsetErrorType = NegativeOffsetError & {\n  name: 'NegativeOffsetError'\n}\nexport class NegativeOffsetError extends BaseError {\n  override name = 'NegativeOffsetError'\n  constructor({ offset }: { offset: number }) {\n    super(`Offset \\`${offset}\\` cannot be negative.`)\n  }\n}\n\nexport type PositionOutOfBoundsErrorType = PositionOutOfBoundsError & {\n  name: 'PositionOutOfBoundsError'\n}\nexport class PositionOutOfBoundsError extends BaseError {\n  override name = 'PositionOutOfBoundsError'\n  constructor({ length, position }: { length: number; position: number }) {\n    super(\n      `Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`,\n    )\n  }\n}\n\nexport type RecursiveReadLimitExceededErrorType =\n  RecursiveReadLimitExceededError & {\n    name: 'RecursiveReadLimitExceededError'\n  }\nexport class RecursiveReadLimitExceededError extends BaseError {\n  override name = 'RecursiveReadLimitExceededError'\n  constructor({ count, limit }: { count: number; limit: number }) {\n    super(\n      `Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`,\n    )\n  }\n}\n"],"names":["number","n","Number","isSafeInteger","Error","bytes","b","Uint8Array","_len","arguments","length","lengths","Array","_key","includes","exists","instance","checkFinished","undefined","destroyed","finished","output","out","min","outputLen","staticCursor","dataView","DataView","ArrayBuffer","position","positionReadCount","Map","recursiveReadCount","recursiveReadLimit","POSITIVE_INFINITY","assertReadLimit","this","RecursiveReadLimitExceededError","count","limit","assertPosition","PositionOutOfBoundsError","decrementPosition","offset","NegativeOffsetError","getReadCount","get","incrementPosition","inspectByte","position_","inspectBytes","subarray","inspectUint8","inspectUint16","getUint16","inspectUint24","getUint8","inspectUint32","getUint32","pushByte","byte","pushBytes","set","pushUint8","value","pushUint16","setUint16","pushUint24","setUint8","pushUint32","setUint32","readByte","_touch","readBytes","size","readUint8","readUint16","readUint24","readUint32","remaining","setPosition","oldPosition","createCursor","cursor","Object","create","buffer","byteOffset","byteLength","SHA2","Hash","constructor","blockLen","padOffset","isLE","super","pos","view","createView","update","data","len","toBytes","take","Math","process","roundClean","digestInto","fill","i","setBigUint64","_32n","BigInt","_u32_max","wh","wl","h","l","oview","outLen","state","digest","res","slice","destroy","_cloneInto","to","Maj","a","c","SHA256_K","Uint32Array","IV","SHA256_W","SHA256","A","B","C","D","E","F","G","H","W15","W2","s0","rotr","s1","T1","T2","Chi","sha256","wrapConstructor","to_","noble_sha256","isHex","strict","toHex","U32_MASK64","fromBig","split","lst","le","Ah","Al","rotlSH","s","rotlSL","rotlBH","rotlBL","SHA3_PI","SHA3_ROTL","_SHA3_IOTA","_0n","_1n","_2n","_7n","_256n","_0x71n","round","R","x","y","push","t","j","SHA3_IOTA_H","SHA3_IOTA_L","rotlH","rotlL","Keccak","suffix","enableXOF","rounds","posOut","state32","u32","keccak","idx1","idx0","B0","B1","Th","Tl","curH","curL","shift","PI","keccakP","finish","writeInto","bufferOut","xofInto","xof","gen","keccak_256","keccak256","receiptStatuses","formatTransactionReceipt","transactionReceipt","receipt","blockNumber","contractAddress","cumulativeGasUsed","effectiveGasPrice","gasUsed","logs","map","log","formatLog","transactionIndex","hexToNumber","status","type","transactionType","blobGasPrice","blobGasUsed","defineTransactionReceipt","defineFormatter","blobsToProofs","parameters","kzg","blobs","hexToBytes","commitments","proofs","blob","commitment","from","computeBlobKzgProof","bytesToHex","ExecutionRevertedError","BaseError","cause","message","reason","replace","defineProperty","FeeCapTooHighError","maxFeePerGas","formatGwei","FeeCapTooLowError","NonceTooHighError","nonce","NonceTooLowError","join","NonceMaxValueError","InsufficientFundsError","metaMessages","IntrinsicGasTooHighError","gas","IntrinsicGasTooLowError","TransactionTypeNotSupportedError","_ref","TipAboveFeeCapError","maxPriorityFeePerGas","UnknownNodeError","_ref2","shortMessage","BlobSizeTooLargeError","maxSize","EmptyBlobError","InvalidVersionedHashSizeError","hash","InvalidVersionedHashVersionError","_ref3","version","versionedHashVersionKzg","concat","values","concatHex","arr","result","concatBytes","reduce","acc","prettyPrint","args","entries","key","filter","Boolean","maxLength","max","padEnd","FeeConflictError","InvalidLegacyVError","_ref4","v","InvalidSerializableTransactionError","_ref5","transaction","InvalidStorageKeySizeError","_ref9","storageKey","floor","TransactionNotFoundError","_ref11","blockHash","blockTag","index","identifier","TransactionReceiptNotFoundError","_ref12","WaitForTransactionReceiptTimeoutError","_ref13","checksumAddressCache","LruMap","checksumAddress","address_","chainId","has","hexAddress","toLowerCase","substring","stringToBytes","address","toUpperCase","formatTransaction","transaction_","gasPrice","maxFeePerBlobGas","typeHex","yParity","accessList","defineTransaction","InvalidAddressError","formatBlock","block","transactions","baseFeePerGas","difficulty","excessBlobGas","gasLimit","logsBloom","timestamp","totalDifficulty","defineBlock","bytesPerFieldElement","fieldElementsPerBlob","bytesPerBlob","maxBytesPerTransaction","toBlobSidecars","size_","active","toBlobs","blobsToCommitments","sidecars","proof","addressRegex","isAddressCache","isAddress","options","test","wei","unit","formatUnits","gweiUnits","start","end","value_","assertStartOffset","assertEndOffset","sliceHex","sliceBytes","SliceOffsetOutOfBoundsError","ChainDoesNotSupportContract","chain","contract","name","blockCreated","ClientChainNotConfiguredError","InvalidChainIdError","u8a","word","str","TextEncoder","encode","utf8ToBytes","clone","hashCons","hashC","msg","tmp","rpcTransactionType","legacy","eip2930","eip1559","eip4844","formatTransactionRequest","request","rpcRequest","blobVersionedHashes","numberToHex","defineTransactionRequest","delete","keys","next","eventName","logIndex","transactionHash","defineChain","formatters","fees","serializers","format","exclude","overrides","formatted","getTransactionType","blobToKzgCommitment","commitmentToVersionedHash","versionedHash","commitmentsToVersionedHashes","hashes"],"sourceRoot":""}